<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Usando Sprites</title>

    <!-- Bootstrap CSS -->
    <link href="../lib/bootstrap-3.2.0-dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Custom CSS -->
    <link href="../css/capitulosCSS/capitulo1.css" rel="stylesheet">


    <body>
        <!--Nav bar -->
        <nav class="navbar navbar-inverse navbar-fixed-top device-fixed-height">
            <div class="container">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                </div>
                <div id="navbar" class="collapse navbar-collapse device-fixed-width">
                    <ul class="nav navbar-nav">
                        <li><a href="../index.html">Inicio</a>
                        </li>
                        <li class="active"><a href="../tutorialesBasico.html">Tutoriales</a>
                        </li>
                        <li><a href="../contact.html">Contacto</a>
                        </li>
                    </ul>
                </div>
                <!--/.nav-collapse -->
            </div>
        </nav>
        <!--Nav bar end-->


        <div class="container afternav">
            <h1>Capítulo 3 - Introducción</h1>
            <p>
                En este capítulo comenzaremos el desarrollo del juego SkyHunter, aprenderemos a configurar la pantalla y a usar Sprites. En cada apartado se proveerá un link de descarga de las clases y recursos usados, se recomienda al final de cada capítulo descargar y colocar esas clases en la carpeta Classes de tu proyecto para compilar sin problemas.
            </p>
            <h2>3.1 Configuración de pantalla </h2>
            <p>
                Tras crear el proyecto, lo primero que haremos será borrar el contenido de nuestra clase HelloWorld.cpp y HelloWorld.h hasta dejarlos como veremos a continuación y posteriormente renombrarlos como GameLayer.cpp y GameLayer.h respectivamente.
                <h3>GameLayer.h</h3>
                <iframe  src="../img/capitulo3/GameLayer.h.html" width="100%" height="300px">Your Browser doesn't support Frames.</iframe>
                <br/>
                <h3>GameLayer.cpp</h3>
                <iframe  src="../img/capitulo3/GameLayer.cpp.html" width="100%" height="300px">Your Browser doesn't support Frames.</iframe>
            </p>
            
            <p>
                Una vez hecho esto, configuraremos la pantalla del juego.<br/>
                Como será un juego para móvil en orientación portrait (vertical), le diremos a cocos que nos muestre una pantalla de ese formato. En mi caso como tengo un Sony Xperia U, le diré a cocos que quiero una ventana de 480x854 <strong>glview->setFrameSize(480, 854)</strong> con esta directiva en AppDelegate.cpp. Si quisiéramos un juego con esta misma resolución en landscape (como si girásemos el móvil) basta con indicar 854x480. Si ejecutamos esto es lo que deberíamos de ver:

                <br/><br/>
                <img class="img-rounded mobile" src="../img/capitulo3/screen.png" alt="solucion visual studio" style="width:100%;"/><br/>
                <br/>
                Como vemos añado una comparación antes de cambiar el tamaño de la pantalla <strong>CC_TARGET_PLATFORM == CC_PLATFORM_WIN32</strong> para que el tamaño de pantalla que muestre cocos sea alterado solo si estamos desarrollando en win32 en este caso. Una vez lanzado en el móvil, este cambio no será efectivo.
            </p>
            <p>
                La última modificación que haremos en esta clase será para decirle a cocos la resolución para la cual fue diseñado nuestro juego y de esta forma el framework automáticamente escalará las imágenes para adaptarlas a la pantalla sobre la que el juego se ejecuta.<br/>
                El juego está diseñado para una resolución de 320x480 y así se lo indicamos a cocos <strong>glview->setDesignResolutionSize(DESING_WIDTH, DESING_HEIGHT, ResolutionPolicy::EXACT_FIT)</strong> con <strong>ResolutionPolicy::EXACT_FIT</strong> le decimos que escale las imágenes para ocupar el total de la pantalla teniendo en cuenta la resolución para la que están diseñadas.<br/>
                Tras todo esto nuestra clase AppDelagate debe de quedar así:

                <br/>
                <h3>AppDelegate.h</h3>
                <iframe  src="../img/capitulo3/AppDelegate.h.html" width="100%" height="300px">Your Browser doesn't support Frames.</iframe>
                <h3>AppDelegate.cpp</h3>
                <iframe  src="../img/capitulo3/AppDelegate.cpp.html" width="100%" height="300px">Your Browser doesn't support Frames.</iframe>
                <br/><br/>Si has llegado hasta aquí, ya tienes tu aplicación configurada para comenzar a desarrollar. A partir de aquí, trabajaremos con Sprites y otros componentes, principalmente en nuestra clase <strong>GameLayer.cpp</strong>. Puedes descargar el código de la aplicación hasta el momento <a href="../img/capitulo3/Classes3.1.zip">aquí</a> y los recursos para el siguiente apartado <a href="../img/capitulo3/recursos.zip">aquí</a>.
            </p>
            <h2>3.2 Usando Sprites</h2>
            <p>
                Lo primero que debemos hacer es copiar las imágenes cuyo link de descarga está arriba, a la carpeta <strong>Resources</strong> y borrar todo su contenido anterior a excepción de la carpeta fonts.
            </p>

            <p>
                Recordar que esta carpeta se encuentra en SkyHunter -> Resources al mismo nivel que la carpeta Classes.
                <br/><br/>
                <img class="img-rounded mobile" src="../img/capitulo3/recursos.png" alt="solucion visual studio" style="width:600px;"/><br/>
            </p>
            <p>
                Ahora que ya tenemos las imagenes incluidas en nuestro proyecto, las podemos utilizar. Para ello usaremos la clase <strong>cocos2d::Sprite</strong> y crearemos a modo de ejemplo el fondo de nuestro juego con <strong>Sprite::create("nombre-imagen")</strong>.
                <br/>
                <img class="img-rounded mobile" src="../img/capitulo3/fondo.png" alt="Añadido fondo al juego" style="width:100%;"/><br/>
            </p>
            <p>
                 Para posicionar el fondo de nuestro juego usamos <strong>fondo->setPosition(visibleSize.width / 2, visibleSize.height / 2)</strong> porque como vimos en el <a href="capitulo12.html">capítulo 2</a> por defecto los sprites tienen su anchor point en el centro entonces como queremos que ocupe toda la pantalla, lo colocamos en el centro de la misma. Cocos automáticamente escalará el sprite gracias a la configuración que pusimos en nuestro AppDelegate.cpp.
            </p>    
            <p>
                Ahora que ya sabemos como funciona la clase Sprite, crearemos las clases para nuestro juego que heredaran de <strong>cocos2d::Sprite</strong> y de <strong>cocos2d::Node</strong>.
                Para comenzar, crearemos una clase Background que se mueva. Para tener sensación de desplazamiento en nuestro juego.
            </p>
                <h3>Background.h</h3>
                <iframe  src="../img/capitulo3/Background.h.html" width="100%" height="300px">Your Browser doesn't support Frames.</iframe>
                <h3>Background.cpp</h3>
                <iframe  src="../img/capitulo3/Background.cpp.html" width="100%" height="300px">Your Browser doesn't support Frames.</iframe><br/><br/>
                <p>
                    Esta clase hereda de Node para poder ser añadida a la escena de cocos, básicamente es un nodo al que se le añaden dos hijos que son dos Sprite simples.<br/>
                    Uno es añadido por encima de la altura de la pantalla por lo que no será visible y otro justo dentro de la pantalla por lo que sí será visible.
                </p>
                <p>
                    En su update se mueven ambos sprites hacia abajo para dar una sensación de movimiento. Una vez que el Sprite que en principio no era visible está situado justo en el centro de la pantalla, se reposiciona a su posición original, de la misma forma el Sprite que al principio estaba situado en el centro de la pantalla es reseteado a su posición inicial cuando ya no es visible al salirse por debajo de la pantalla.<br/> Mejor veámoslo ilustrado.<br/><br/>
                    <center><img class="img-rounded " src="../img/capitulo3/backgroundExpliation.png" alt="expliacion del funcionamiento del background" style="width:300px;"/><br/></center>
                    <br/><br/>
                    También usamos dos macros <strong>CC_SYNTHESIZE</strong> ya nombrada en el capítulo anterior, que nos permite generar rápidamente getters y setters y el segundo macro <strong>CREATE_FUNC</strong> que genera automáticamente el método estático <strong>create()</strong> para esta clase.
                </p>
                <p>
                    Excelente, ahora sólo falta decirle a nuestro juego que añada el nuevo background en lugar del que teníamos inicialmente y hacer que este background se mueva.
                </p>
                 <h3>GameLayer.h</h3>
                <iframe  src="../img/capitulo3/GameLayer2.h.html" width="100%" height="300px">Your Browser doesn't support Frames.</iframe>
                <h3>GameLayer.cpp</h3>
                <iframe  src="../img/capitulo3/GameLayer2.cpp.html" width="100%" height="300px">Your Browser doesn't support Frames.</iframe>
                <br/><br/>
                <p>
                    Como podemos ver, hemos creado un método update y le decimos al framework que incluya en el ciclo del juego ese método update mediante <strong>this->schedule(schedule_selector(GameLayer::update))</strong> (no es necesario que el método se llame update pero sí que reciba un float como parámetro y sea void), 
                    <strong>schedule_selector</strong> es uno de esos macros especiales que cocos2d-x incluye para facilitar el desarrollo de nuestro juego.
                    En el <strong>update</strong> recibiremos como parámetro la cantidad de tiempo que transcurrió desde la última vez que se ejecutó. Para garantizar que el juego trabaja siempre a la misma velocidad, multiplicaremos la velocidad a la que se mueven todos los elementos por <strong>dt</strong> tal y como hicimos en el método update de la clase <strong>Background</strong> que es llamado desde aquí al igual que todos los métodos update de los diferentes componentes que iremos creando.
                </p>
                <p>
                    Puedes descargar las carpetas Classes y Resources del proyecto hasta el momento <a href="../img/capitulo3/SkyHunter3.2.zip">aquí</a>. 
                </p>
            <!-- end container -->
        </div>

        <!-- next chapter link -->
        <div>
            <br/>
            <center>
                <a  href="capitulo2.html" >
                    <span class="glyphicon glyphicon-arrow-left" aria-hidden="true"></span> Capítulo anterior
                </a>
                |
                <a  href="capitulo4.html" >
                    Capítulo siguiente <span class="glyphicon glyphicon-arrow-right" aria-hidden="true"></span> 
                </a>
            </center>
            <br/>
        </div>


        <!-- BOOTSTRAP CORE JS -->
        <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
        <script src="../js/jquery-1.11.1.min.js"></script>
        <!-- Include all compiled plugins (below), or include individual files as needed -->
        <script src="../lib/bootstrap-3.2.0-dist/js/bootstrap.min.js"></script>
        <script>
            // from https://signalvnoise.com/posts/2407-device-scale-user-interface-elements-in-ios-mobile-safari
            function getDeviceScale() {
                var deviceWidth, landscape = Math.abs(window.orientation) == 90;
                if (landscape) {
                  // iPhone OS < 3.2 reports a screen height of 396px
                  deviceWidth = Math.max(480, screen.height);
                } else {
                  deviceWidth = screen.width;
                }
                return window.innerWidth / deviceWidth;
            }

            // mobile only - keep the position:fixed header at constant size when page is zoomed
            if (navigator.userAgent.match(/Mobi/)) {
                $(window).on('load scroll', function() {
                    var ds = getDeviceScale();
                    $('.device-fixed-height').css('transform','scale(1,' + ds + ')')
                        .css('transform-origin', '0 0');
                    $('.device-fixed-width').css('transform', 'scale(' + ds + ',1)')
                        .css('transform-origin', '0 0');
                    })
            }
        </script>
         <script>
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
            })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

            ga('create', 'UA-63954706-1', 'auto');
            ga('send', 'pageview');
        </script>
    </body>

</html>