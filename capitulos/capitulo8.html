<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Creando Sky Hunter</title>

    <!-- Bootstrap CSS -->
    <link href="../lib/bootstrap-3.2.0-dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Custom CSS -->
    <link href="../css/capitulosCSS/capitulo1.css" rel="stylesheet">


    <body>
        <!--Nav bar -->
        <nav class="navbar navbar-inverse navbar-fixed-top device-fixed-height">
            <div class="container">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                </div>
                <div id="navbar" class="collapse navbar-collapse device-fixed-width">
                    <ul class="nav navbar-nav">
                        <li><a href="../index.html">Inicio</a>
                        </li>
                        <li class="active"><a href="../tutorialesBasico.html">Tutoriales</a>
                        </li>
                        <li><a href="../contact.html">Contacto</a>
                        </li>

                    </ul>
                </div>
                <!--/.nav-collapse -->
            </div>
        </nav>
        <!--Nav bar end-->


        <div class="container afternav">
            <h1>Capítulo 8 - Introducción</h1>
            <p>
                En este capítulo aprenderemos como usar  <strong>ui/CocosGUI.h</strong>. Nuestro proyecto ha sufrido una completa reestructuración para facilitar la extensión de nuestro juego, la lógica que ya conocemos hasta el momento se mantiene intacta.
            </p>
            <p>
                Tan solo explicaremos el uso de los componentes pues el código es suficientemente autoexplicativo. Descarga el proyecto para analizar su código buscando el tag Ch-6 en el repositorio de <a href="https://github.com/Seryusjj/Sky-Hunter/tree/Ch-6">GitHub</a>.
            </p> 
            <h2>Capítulo 6.1 - GameManager, manteniendo los avances del jugador</h2>
            <p>
                Queremos que el usuario pueda cambiar el volumen del sonido de fondo y de los efectos como los disparos o explosiones, además queremos guardar cuantos niveles ha superado y así saber cuál es el siguiente a desbloquear, todo esto lo gestionaremos mediante un singleto llamado GameManager que nos facilitará el trabajo. Echemos un vistazo a su implementación.
            </p>
            <h3>GameManager.h</h3>
            <iframe  src="../img/capitulo8/GameManager.h.html" width="100%" height="300px">Your Browser doesn't support Frames.</iframe>
            <h3>GameManager.cpp</h3>
            <iframe  src="../img/capitulo8/GameManager.cpp.html" width="100%" height="300px">Your Browser doesn't support Frames.</iframe>
            <p>
                Como vemos es simplemente una clase que nos proveé funciones para guardar datos en persistencia, <strong>UserDefault::getInstance()</strong> es quien realemnte hace el trabajo pues nos permite almacenar datos mediaante clave - valor igual que un hasmap en la persistencia de forma transparente a la plataforma en la que el juego se ejecuta, ya sea windows android IOS ... etc.
            </p>
            <p>
                Nuesto GameManager además de permitir guardar estos datos, también lleva la cuenta de la puntuación de la partida, aunque no la guarda en persistencia. Hace persistente el volumen especificado por el usuario, el siguiente nivel que el usuario puede jugar y la maxima puntiación obtenida por el jugador, este ultimo valor se usará en el modo de juego arcade.
            </p>
            <h2>Capítulo 6.2 - Menús</h2>
            <p>
                Todos nuestros menús heredan de una clase común pues todos tendrán el mismo fondo con un comportamiento identico, heredaran de <strong>BaseMenuLayer.cpp</strong> y crearemos varios menús: MainMenuLayer, OptionsLayer, SelectMenuLayer mostrados consecutivamente abajo.
            </p>
            <center>
                <img class="img-rounded " src="../img/capitulo8/main_menu.png" alt="menu principal" style="width:300px;margin-top:5px;"/>
                <img class="img-rounded " src="../img/capitulo8/options.png" alt="menu principal" style="width:300px;margin-top:5px;"/>
                <img class="img-rounded " src="../img/capitulo8/level_selector.png" alt="menu principal" style="width:300px;margin-top:5px;"/>
            </center>
            <br/>
            <p>
                Como todos los menús son muy parecidos en cuanto a implementación, explicaré el BaseMenuLayer del cuál heredan todos los menús excepto SelectMenuLayer que hereda de MainMenuLayer así que explicaremos estos 3.
            </p>
            <h3>BaseMenuLayer.h</h3>
            <iframe  src="../img/capitulo8/BaseMenuLayer.h.html" width="100%" height="300px">Your Browser doesn't support Frames.</iframe>
            <h3>BaseMenuLayer.cpp</h3>
            <iframe  src="../img/capitulo8/BaseMenuLayer.cpp.html" width="100%" height="300px">Your Browser doesn't support Frames.</iframe>
            <p>Nada que explicar realmente acerca de esta clase más que usa una clase Background, en su init() llamamos al scheduler para lanzar el update. Como ya lo hacemos en la clase padre, es muy importante no volver a hacerlo en la clase hija, lo que si podemos hacer es un override del metodo update, sin embargo no nos interesa ya que este update taan solo moverá el fondo del menú, a contuniación veremos por que no necesitamos hacer override del update</p>

            <h3>MainMenuLayer.h</h3>
            <iframe  src="../img/capitulo8/MainMenuLayer.h.html" width="100%" height="300px">Your Browser doesn't support Frames.</iframe>
            <h3>MainMenuLayer.cpp</h3>
            <iframe  src="../img/capitulo8/MainMenuLayer.cpp.html" width="100%" height="300px">Your Browser doesn't support Frames.</iframe>
            <p>
                MainMenuLayer hereda de la calse anterior y añade a la escena una serie de botonos, estos botones pertenecen a <strong>ui/CocosGUI.h</strong>.Para crearlos, se le idnica la imagen de su estado normal, la imagen de su estado al pulsar y la imagen a mostrar cuando inhabilitamos el boton. Como vemos las acciones de los botones se indican mediante call backs con lo que no necesitamos sobreescribir el metodo update de la clase padre.
            </p>
            <p>
                 Prestemos especial antención al boton start y al vector de punteros a función, <strong>initFunctions</strong> es una función que nos permite inicializar un vector con una serie de punteros a funciones, esto nos sirve para saber qué nivel debe lanzar el boton <strong>Start</strong> pues basta con obtener el numero del nivel a lanzar del GameManager y cargarlo en el boton a traves del vector _functions <strong>_functions.at(GameManager::getInstance()->getNextLevel())</strong>. 
            </p>
            <p>
                Los niveles que se deben lanzar en función de la elección del GameManager están sin implementar, por el momento solo tenemos el nivel 1, el resto los crearemos en el capítulo 7 y en el apartado 6.3 de este capítulo analizaremos elementos como la barra de salud o cómo mostrar la puntuación del jugador.
            </p>

            <h3>SelectMenuLayer.h</h3>
            <iframe  src="../img/capitulo8/SelectMenuLayer.h.html" width="100%" height="300px">Your Browser doesn't support Frames.</iframe>
            <h3>SelectMenuLayer.cpp</h3>
            <iframe  src="../img/capitulo8/SelectMenuLayer.cpp.html" width="100%" height="300px">Your Browser doesn't support Frames.</iframe>
            <p>Este menú muestra en forma de matríz una serie de botones, que nos dicen qué niveles hemos superado y cual es el siguiente nivel a jugar. Si superamos el nivel 1, se desbloqueara el 2 y así sucesivamente</p>
            <p>
                En el método <strong>initButtons</strong> se crean los botones, algo muy importante a tener en cuenta es que cualquier valor absoluto que demos para posicionar objetos debe multiplicarse por el factor de escalado en el eje X ó Y según corresponda para que de esta forma siempre se vea igual al cambiar el tamaño de la pantalla. Sabiendo esto, vemos que este metodo tan solo itera y coloca botones dandoles su posición además de configurarlos, es decir los coloca y según el número de boton, este ha de hacer una coso u otra, para cargarle la funcionalidad usamos un vector inicializado con las acciones que su clase padre MainMenuLayer provee.
            </p>
            <p>
                Por defecto todos los botones creados estarán deshabilitados y mostraran la imagen con el candado cerrado, así que tras añadirlos a la escena, iteramos hasta donde GameManager indique y desbloquemaos todos los niveles hasta el siguiente nivel que el usuario haya desbloqueado jugando.
                Por último se crea un boton para volver al menu principal.
            </p>
            <p>
                En todas las clases de menú usamos ui/CocosGUI.h en el último menú cuya implentación no mostraremos (descargase proyecto completo) se ve como usar Sliders (otro componente como Button). Para más información acerca de componentes de interfac de usuario dirigete a la <a href="http://www.cocos2d-x.org/reference/native-cpp/V3.6/index.html">API reference</a>
            </p>

            <h2>Capítulo 6.3 - Score, Salud y botón de pausa</h2>
            <p>
                Si recordais nuestra GameLayer de capítulos anteriores, ahora se llama Level1 y hereda de BaseGameLayer, en esta clase BaseGameLayer, se encuentra la interfaz de nuestro juego y la lógica para manejarla así como aquellos componetes comunes a todos los niveles (el player, la UI, alguna lógica ...etc). Así que para explicar la interfaz, comenzaremos explicando la clase BaseGameLayer
            </p>
            <h3>BaseGameLayer.h</h3>
            <iframe  src="../img/capitulo8/BaseGameLayer.h.html" width="100%" height="300px">Your Browser doesn't support Frames.</iframe>
            <h3>BaseGameLayer.cpp</h3>
            <iframe  src="../img/capitulo8/BaseGameLayer.cpp.html" width="100%" height="300px">Your Browser doesn't support Frames.</iframe>
            <p>
                Como vemos todos los elementos comunes a  todos los niveles, entre ellos las UI estan encapsulados en esta clase, también su lógica, no es una clase compleja, ya que casi todos los metodos son de creación y posicionamiento de elementos. Prestaremos especial atecnión a como se ha creado la barra de salud y al metodo update de esta clase. Pare ello mira el metodo <strong>createHealthIndicator</strong> donde componemos y añadimos a la escena la barra de salud, esta barra tiene 3 componentes: healthContainerIndicator una imagen de una nave pequeña que indica que esa es la salud del jugador, healthContainer, una imagen de fondo para la barra de salud y por último la barra roja de salud healthBar para que esta barra se comporte como es debido se debe posicionar su anchorPoint en 0, 0.5 ya que no solo el posicionamiento de los Sprites va en función del anchor point sino también su rotación y escalado.
            </p>
            <p>
                Ahora que ya posicionamos la barra de salud echemos un ojo al <strong>update</strong> en concreto a la linea que pone <strong>_healthBar->setScaleX(static_cast(_player->getHealth()) / static_cast(MAX_HEALTH));</strong> como vemos se modifica el tamaño de la barra en función de la cantidad de vida que tiene el jugagdor escalando la barra, el factor de escalado lo obtenemos dividiendo el número de vidas del jugador entre la vida total del mismo.
            </p>
            <p>
                En este metodo update también se gestiona qué debe aparecer en el Label de puntua´ción y porcentaje de completado del nivel. Si el jugador completa el nievel, se llama a la función <strong>levelCompleteActions</strong> que muestra un texto en pantalla para indicar que se completó el nivel y tras un par de segundos lanza al jugador a la pantall de selección de nivel para que elija si quiere jugar el siguiente nivel o jugar uno que ya haya superado. Además guarda mediante el GameManager el nivel superado por el jugador.
            </p>
            <p>
                El resto de componentes no es demasiado difícil advertir su funcionamiento así qu no los veremos en profundida. Mejor vemos el comportamiento de una clase derivada de esta.
            </p>
            <h3>Level1.h</h3>
            <iframe  src="../img/capitulo8/Level1.h.html" width="100%" height="300px">Your Browser doesn't support Frames.</iframe>
            <h3>Level1.cpp</h3>
            <iframe  src="../img/capitulo8/Level1.cpp.html" width="100%" height="300px">Your Browser doesn't support Frames.</iframe>
            <p>
                Esta clase equivale a la que llamabamos GameLayer en capítulos anteriores. Como vemos hereda de BaseGameLayer veamos como se comporta.
            </p>
            <p>
                En su metodo init() se llama antes al init de la superclase BaseGameLayer no al de Layer::init() además en su update antes llama al update de la superclase BaseGameLayer::update(dt).El resto ya lo conocemos de capítulos anteriores como la forma de lanzar enemigos en el juego.
            </p>
            <p>
                Además se implemente el metodo pauseButtonAction y resumeButtonAction sobreescribiendo los de la superclase para indicar cómo pausar el juego.Para más detalles acerca de esto echaremos un ojo más adelante al metodo pause de la clase Player. Este es el aspecto que presenta hasta este punto nuestro primer nivel.
            </p>
            <center>
                <img class="img-rounded " src="../img/capitulo8/playing.png" alt="menu principal" style="width:300px;margin-top:5px;"/>
                <img class="img-rounded " src="../img/capitulo8/pause.png" alt="menu principal" style="width:300px;margin-top:5px;"/>
                <img class="img-rounded " src="../img/capitulo8/dead.png" alt="menu principal" style="width:300px;margin-top:5px;"/>
            </center>        
            <!-- end container -->
        </div>

        <!-- next chapter link -->
        <div>
            <br/>
            <center>
                <a  href="capitulo7.html" >
                    <span class="glyphicon glyphicon-arrow-left" aria-hidden="true"></span> Capítulo anterior
                </a>
                |
                <a  href="#" >
                    Capítulo siguiente <span class="glyphicon glyphicon-arrow-right" aria-hidden="true"></span> 
                </a>
            </center>
            <br/>
        </div>


        <!-- BOOTSTRAP CORE JS -->
        <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
        <script src="../js/jquery-1.11.1.min.js"></script>
        <!-- Include all compiled plugins (below), or include individual files as needed -->
        <script src="../lib/bootstrap-3.2.0-dist/js/bootstrap.min.js"></script>
        <script>
            // from https://signalvnoise.com/posts/2407-device-scale-user-interface-elements-in-ios-mobile-safari
            function getDeviceScale() {
                var deviceWidth, landscape = Math.abs(window.orientation) == 90;
                if (landscape) {
                  // iPhone OS < 3.2 reports a screen height of 396px
                  deviceWidth = Math.max(480, screen.height);
                } else {
                  deviceWidth = screen.width;
                }
                return window.innerWidth / deviceWidth;
            }

            // mobile only - keep the position:fixed header at constant size when page is zoomed
            if (navigator.userAgent.match(/Mobi/)) {
                $(window).on('load scroll', function() {
                    var ds = getDeviceScale();
                    $('.device-fixed-height').css('transform','scale(1,' + ds + ')')
                        .css('transform-origin', '0 0');
                    $('.device-fixed-width').css('transform', 'scale(' + ds + ',1)')
                        .css('transform-origin', '0 0');
                    })
            }
        </script>
    </body>

</html>