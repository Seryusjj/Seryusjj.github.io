<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Creando Sky Hunter</title>

    <!-- Bootstrap CSS -->
    <link href="../lib/bootstrap-3.2.0-dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Custom CSS -->
    <link href="../css/capitulosCSS/capitulo1.css" rel="stylesheet">


    <body>
        <!--Nav bar -->
        <nav class="navbar navbar-inverse navbar-fixed-top device-fixed-height">
            <div class="container">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                </div>
                <div id="navbar" class="collapse navbar-collapse device-fixed-width">
                    <ul class="nav navbar-nav">
                        <li><a href="../index.html">Home</a>
                        </li>
                        <li class="active"><a href="../tutorialesBasico.html">Tutoriales</a>
                        </li>
                        <li><a href="../contact.html">Contact</a>
                        </li>
                    </ul>
                </div>
                <!--/.nav-collapse -->
            </div>
        </nav>
        <!--Nav bar end-->


        <div class="container afternav">
            <h1>Capítulo 5 - Introducción</h1>
            <p>
                En este capítulo aprenderemos como optimizar nuestro juego empaquetando texturas y a añadir sonidos a nuestro juego.
            </p>
            <h2>Capítulo 5.1 - Optimizando</h2>
            <p>
                Aquí biene un poco de teoria, ¿por qué necesitamos empaquetar las texturas? pues bien para minimizar el número de accesos a disco gracias a que cocos provee un clase llamada SpriteBatchNode que funciona de la siguiente manera: inicialmente se carga un descriptor en el SpriteFrameCahe, este descriptor es un .plist (una especie de xml pero para mac) pues bien una vez cargado el descriptor en la cache, podremos crear sprites a partir de los nombres cargados en dicho descriptor obviamente solo con dicho descriptor no podemos renderizar imagenes. Despues de cargar este descriptor, creamos el SpriteBatchNode a partir de la spritesheet con las texturas que especifica el descriptor y a partir de qui cualquier sprite que creemos con el SpriteFrameCache lo añadimos al SpriteBatchNode con addChildren y automaticamente le asiganrá la textura correspondiente. Además de minimizar el numero de accesos a disco, añade otra ventaja muy importante. cuando creamos sprites con su metodo create, se genera un batch para rendirizar dicho sprite, de esta nueva forma solo se genera un batch para el SpriteBatchNode que permite renderizar todos los sus nodos hijos, esto es una ventaja muy importante pues crear dicho batch es muy costoso.
            </p>
            <p>
                ¿Cómo pueddo empaquetar mis texturas? hay varias herramientas en el mercado como TexturePacker pero son de pago, yo recomiendo usar <a href="https://code.google.com/p/libgdx-texturepacker-gui/">libgdx-texturepacker-gui</a> que es una herramiento de empaquetado de otro framework llamado libgdx. Sin embargo el formato del descriptor no es compatible con cocos por eso he realizado un pequeño script en java para transformar el formato del empaquetador a .plist <a href="https://github.com/Seryusjj/Atlas2Plist">Aquí esta el codigo del parser</a> y de este otro link puedes bajar las texturas empaquetadas y el script para generar el .plist <a href="../img/capitulo7/SkyHunterResources.zip"></a>
            </p>
            <p>
                El resultado final de empaquetar nuestras texturas será algo asi:
            </p>
             <center><img class="img-rounded " src="../img/capitulo7/Hunter.png" alt="enenmigo y jugador posicionados en el GameLayer" style="width:350px;"/><br/></center><br/>
             <p>
                Una única imagen con todos los sprites. Veamos un poco de código para ver como usar el SpriteBatchNode, con ver el GameLayer y la clase Player será suficiente.
             </p>
             <h3>GameLayer.cpp</h3>
             <iframe  src="../img/capitulo7/GameLayer.cpp.html" width="100%" height="300px">Your Browser doesn't support Frames.</iframe>
             <p>
                Tan solo hae falta ijarse en el init() la lógia se mantiene igual que en los capítulos anteriores. Como vemos tal y como dijimos previamente, primero cargarmos el descriptor en la caché con <strong>SpriteFrameCache::getInstance()->addSpriteFramesWithFile("Hunter.plist")</strong> y luego creamos el batchNode <strong>SpriteBatchNode* gameBatchNode = SpriteBatchNode::create("Hunter.png")</strong> y ara finalizar añadimos a la escena dicho nodo.
             </p>
             <p>
                El resto de clases las añadimos como hijas de este nodo, este nodo solo puede tener como nodos hijo, nodos Sprite o clases derivadas. Es por esto que nuestro TouchController pasará a heredar de Sprite en lugar de Node.
             </p>
             <p>
                Veamos como crear Sprites a partir de la caché.
             </p>

             <h3>Player.cpp</h3>
             <iframe  src="../img/capitulo7/Player.cpp.html" width="100%" height="300px">Your Browser doesn't support Frames.</iframe>

             <p>
                Aquí tenemos nuestra ya conocida clase Player, veamos en que ha cambiado. Si echamos un ojo al metodo <strong>createIdleAnimation()</strong> podremos apreciar que los frames de las animaciones ya no se crean igual, ahora usamos <strong>priteFrameCache::getInstance()->getSpriteFrameByName(name)</strong>. La clase Sprite tambien permite crear sprites a aprtir de un spriteFrame name sin necsidad de usar la caché de la siguiten forma <strong>Sprite::createWithSpriteFrameName(name)</strong> es importante añadir cualquier nodo creado de esta forma a un nodo padre <strong>SpriteBatchNode</strong> que contenga la información necesaria para completar al nodo hijo creado a partir del descriptor. de no ser así obtendremos un error al ejecutar el juego.
             </p>
              <p>Descarga el juego actualizo con SpriteBatchNode buscando el <strong>tag Ch-5.1</strong> en el repositorio de <a href="https://github.com/Seryusjj/Sky-Hunter/tree/Ch-5.1">GitHub</a></p>

            <h2>Capítulo 5.2 - Sonidos</h2>
            <p>
                Ahora vamos a añadir un par de sonidos muy simples, algunos de ellos creados con <a href="http://www.superflashbros.net/as3sfxr/">as3sfxr</a> y otros obtenidos de <a href="opengameart.org">opengameart.org</a>
            </p>
            <p>
                Para comenzar crea una carpeta llamada <strong>music</strong>  dentro de tu carpeta <strong>resources</strong> y añade estos <a href="../img/capitulo7/music.zip">sonidos</a>
            </p>
            <p>
                Ahora que tenemos los sonidos, vamos a cargarlos en nuestra clase AppDelegate.cpp usando SimpleAudioEngine.
            </p>
            <h3>AppDelegate.cpp</h3>
             <iframe  src="../img/capitulo7/AppDelegate.cpp.html" width="100%" height="300px">Your Browser doesn't support Frames.</iframe>
             <p>
                Añadimos <strong>#include "SimpleAudioEngine.h"</strong> y el namespace <strong>CocosDenshion</strong>, luego cargamos los sonidos tanto si son efectos como si son un sonido de backgroudn mediante el singleton <strong>SimpleAudioEngine::getInstance()</strong> y ajustamos el volumen.
             </p>

             <p>
                Para reproducir los sonidos basta con usar los metodos <strong>playBackgroundMusic</strong> o <strong>SimpleAudioEngine::getInstance()->playEffect("music/Laser_Shoot6.wav");</strong> .
             </p>
             <p>
                Descarga la aplicacuón con los sonidos integrados buscando el <strong>tag Ch-5.2</strong> en el repositorio de <a href="https://github.com/Seryusjj/Sky-Hunter/tree/Ch-5.2_fix">GitHub</a></p>
             </p>
             <p>
                Nota: Este sitema de sonido no permite modificar el volumen, aunquer las interfaces están ahí, cocos2d-x no lo implementa asi que en futuras versiones usaramoes <strong>AudioEngine.h</strong> del namespace experimental, este sistema permite modificar el volumne del sonido y en lugar de un singleton, proporciona metodos estaticos por lo que su uso no tiene mayor complejidad que <strong>experimental::AudioEngine::play2d("songname.mp3", (loop= true| false), (volume = 0-1));</strong></p> para que funcione usar formato de audio mp3.
            </p>
            <p>
                En el capítulo 6, el proyecto integra el sistema de sonido de <strong>AudioEngine.h</strong>.
            </p>


            <!-- end container -->
        </div>

        <!-- next chapter link -->
        <div>
            <br/>
            <center>
                <a  href="capitulo6.html" >
                    <span class="glyphicon glyphicon-arrow-left" aria-hidden="true"></span> Capítulo anterior
                </a>
                |
                <a  href="capitulo8.html" >
                    Capítulo siguiente <span class="glyphicon glyphicon-arrow-right" aria-hidden="true"></span> 
                </a>
            </center>
            <br/>
        </div>


        <!-- BOOTSTRAP CORE JS -->
        <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
        <script src="../js/jquery-1.11.1.min.js"></script>
        <!-- Include all compiled plugins (below), or include individual files as needed -->
        <script src="../lib/bootstrap-3.2.0-dist/js/bootstrap.min.js"></script>
        <script>
            // from https://signalvnoise.com/posts/2407-device-scale-user-interface-elements-in-ios-mobile-safari
            function getDeviceScale() {
                var deviceWidth, landscape = Math.abs(window.orientation) == 90;
                if (landscape) {
                  // iPhone OS < 3.2 reports a screen height of 396px
                  deviceWidth = Math.max(480, screen.height);
                } else {
                  deviceWidth = screen.width;
                }
                return window.innerWidth / deviceWidth;
            }

            // mobile only - keep the position:fixed header at constant size when page is zoomed
            if (navigator.userAgent.match(/Mobi/)) {
                $(window).on('load scroll', function() {
                    var ds = getDeviceScale();
                    $('.device-fixed-height').css('transform','scale(1,' + ds + ')')
                        .css('transform-origin', '0 0');
                    $('.device-fixed-width').css('transform', 'scale(' + ds + ',1)')
                        .css('transform-origin', '0 0');
                    })
            }
        </script>
    </body>

</html>